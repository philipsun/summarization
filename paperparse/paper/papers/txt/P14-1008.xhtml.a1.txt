 Dependency-based Compositional Semantics (DCS) is a framework of natural language semantics with easy-to-process structures as well as strict semantics. In this paper, we equip the DCS framework with logical inference, by defining abstract denotations as an abstraction of the computing process of denotations in original DCS. An inference engine is built to achieve inference on abstract denotations. Furthermore, we propose a way to generate on-the-fly knowledge in logical inference, by combining our framework with the idea of tree transformation. Experiments on FraCaS and PASCAL RTE datasets show promising results. Abstract denotations are formulas constructed from a minimal set of relational algebra [] operators, which is already able to formulate the database queries defined by DCS trees. For example, the semantics of u'\u201c' students read books u'\u201d' is given by the abstract denotation: where read , student and book denote sets represented by these words respectively, and w r represents the set w considered as the domain of the semantic role r (e.g. u'\ud835' u'\udc1b' u'\ud835' u'\udc28' u'\ud835' u'\udc28' u'\ud835' u'\udc24' u'\ud835' u'\ude7e' u'\ud835' u'\ude71' u'\ud835' u'\ude79' is the set of books considered as objects). The operators u'\u2229' and × represent intersection and Cartesian product respectively, both borrowed from relational algebra. It is not hard to see the abstract denotation denotes the intersection of the u'\u201c' reading u'\u201d' set (as illustrated by the u'\u201c' read u'\u201d' table in Table 1 ) with the product of u'\u201c' student u'\u201d' set and u'\u201c' book u'\u201d' set, which results in the same denotation as computed by the DCS tree in Figure 1 , i.e. { John reads Ulysses , u'\u2026' } . However, the point is that F 1 itself is an algebraic formula that does not depend on any concrete databases. Formally, we introduce the following constants : W : a universal set containing all entities. Content words: a content word (e.g. read ) defines a set representing the word (e.g. u'\ud835' u'\udc2b' u'\ud835' u'\udc1e' u'\ud835' u'\udc1a' u'\ud835' u'\udc1d' = { ( x , y ) | u'\u2005' r u'\u2062' e u'\u2062' a u'\u2062' d u'\u2062' ( x , y ) } ). In addition we introduce following functions : × : the Cartesian product of two sets. u'\u2229' : the intersection of two sets. u'\u03a0' r : projection onto domain of semantic role r (e.g. u'\u03a0' u'\ud835' u'\ude7e' u'\ud835' u'\ude71' u'\ud835' u'\ude79' u'\u2062' ( u'\ud835' u'\udc2b' u'\ud835' u'\udc1e' u'\ud835' u'\udc1a' u'\ud835' u'\udc1d' ) = { y | u'\u2005' u'\u2203' x ; r u'\u2062' e u'\u2062' a u'\u2062' d u'\u2062' ( x , y ) } ). Generally we admit projections onto multiple semantics roles, denoted by u'\u03a0' R where R is a set of semantic roles. u'\u0399' r : relabeling (e.g. u'\u0399' u'\ud835' u'\ude7e' u'\ud835' u'\ude71' u'\ud835' u'\ude79' u'\u2062' ( u'\ud835' u'\udc1b' u'\ud835' u'\udc28' u'\ud835' u'\udc28' u'\ud835' u'\udc24' ) = u'\ud835' u'\udc1b' u'\ud835' u'\udc28' u'\ud835' u'\udc28' u'\ud835' u'\udc24' u'\ud835' u'\ude7e' u'\ud835' u'\ude71' u'\ud835' u'\ude79' ). q u'\u2282' r : the division operator, where q u'\u2282' r u'\u2062' ( A , B ) is defined as the largest set X which satisfies B r × X u'\u2282' A . 2 2 If A and B has the same dimension, q u'\u2282' u'\u2062' ( A , B ) is either u'\u2205' or { * } ( 0 -dimension point set), depending on if A u'\u2282' B . This is used to formulate universal quantifiers, such as u'\u201c' Mary loves every dog u'\u201d' and u'\u201c' books read by all students u'\u201d' . An abstract denotation is then defined as finite applications of functions on either constants or other abstract denotations.